import express from 'express';
import fetch from 'node-fetch';
import jwt from 'jsonwebtoken';
import { authenticateToken } from '../middleware/auth.js';
import DiscordLink from '../models/DiscordLink.js';
import { sendMessageToDiscordChannel, sendDirectMessageToUser, assignRoleToUser, addUserToGuild } from '../utils/sendDiscordMessage.js';
import { maskWalletAddress, maskDiscordId } from '../utils/privacyUtils.js';

const router = express.Router();

// Configuration Discord OAuth2
const DISCORD_CLIENT_ID = process.env.DISCORD_CLIENT_ID;
const DISCORD_CLIENT_SECRET = process.env.DISCORD_CLIENT_SECRET;
const DISCORD_REDIRECT_URI = process.env.DISCORD_REDIRECT_URI || 'https://lastexitvpn.duckdns.org/discord/callback';
const DISCORD_API_ENDPOINT = 'https://discord.com/api/v10';

// Log des variables d'environnement pour le d√©bogage
console.log('Variables d\'environnement Discord:', {
  DISCORD_CLIENT_ID,
  DISCORD_CLIENT_SECRET: DISCORD_CLIENT_SECRET ? '***' : 'non d√©fini',
  DISCORD_REDIRECT_URI,
  NODE_ENV: process.env.NODE_ENV
});

// Route pour initier l'authentification Discord
router.get('/auth', authenticateToken, (req, res) => {
  // R√©cup√©rer l'adresse du wallet depuis le token JWT
  const walletAddress = req.user.address || req.user.walletAddress;
  
  if (!walletAddress) {
    return res.status(401).json({
      success: false,
      message: 'Vous devez √™tre connect√© avec un wallet pour lier votre compte Discord'
    });
  }
  
  // Cr√©er l'URL d'authentification Discord
  const state = Buffer.from(JSON.stringify({ walletAddress })).toString('base64');
  
  // Inclure le scope guilds.join pour permettre l'ajout automatique au serveur
  const discordAuthUrl = `https://discord.com/api/oauth2/authorize?client_id=${DISCORD_CLIENT_ID}&redirect_uri=${encodeURIComponent(DISCORD_REDIRECT_URI)}&response_type=code&scope=identify%20guilds.join&state=${state}`;
  
  res.json({
    success: true,
    authUrl: discordAuthUrl
  });
});

// Route pour compl√©ter la liaison Discord depuis le frontend
router.post('/complete-link', authenticateToken, async (req, res) => {
  try {
    // R√©cup√©rer l'adresse du wallet depuis le token JWT
    const walletAddress = req.user.address || req.user.walletAddress;
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour lier votre compte Discord'
      });
    }
    
    const { code } = req.body;
    
    if (!code) {
      return res.status(400).json({
        success: false,
        message: 'Code d\'autorisation Discord manquant'
      });
    }
    
    console.log(`Tentative de liaison Discord pour le wallet ${walletAddress} avec le code ${code.substring(0, 10)}...`);
    
    // V√©rifier que les variables d'environnement Discord sont d√©finies
    if (!DISCORD_CLIENT_ID || !DISCORD_CLIENT_SECRET) {
      console.error('Variables d\'environnement Discord manquantes:', { 
        DISCORD_CLIENT_ID: !!DISCORD_CLIENT_ID, 
        DISCORD_CLIENT_SECRET: !!DISCORD_CLIENT_SECRET 
      });
      return res.status(500).json({
        success: false,
        message: 'Configuration Discord manquante sur le serveur'
      });
    }

    // √âchanger le code contre un token d'acc√®s Discord
    try {
      const tokenResponse = await fetch(`${DISCORD_API_ENDPOINT}/oauth2/token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: new URLSearchParams({
          client_id: DISCORD_CLIENT_ID,
          client_secret: DISCORD_CLIENT_SECRET,
          grant_type: 'authorization_code',
          code,
          redirect_uri: DISCORD_REDIRECT_URI
        })
      });
      
      // V√©rifier si la r√©ponse est OK
      if (!tokenResponse.ok) {
        const errorText = await tokenResponse.text();
        console.error('Erreur lors de l\'obtention du token Discord:', {
          status: tokenResponse.status,
          statusText: tokenResponse.statusText,
          error: errorText
        });
        return res.status(500).json({
          success: false,
          message: `Erreur lors de l'√©change du code: ${tokenResponse.status} ${tokenResponse.statusText}`
        });
      }
      
      const tokenData = await tokenResponse.json();
      
      if (!tokenData.access_token) {
        console.error('Erreur lors de l\'\u00e9change du code:', tokenData);
        return res.status(500).json({
          success: false,
          message: 'Erreur lors de l\'\u00e9change du code d\'autorisation'
        });
      }
      
      // R√©cup√©rer les informations de l'utilisateur Discord
      const userResponse = await fetch(`${DISCORD_API_ENDPOINT}/users/@me`, {
        headers: {
          Authorization: `Bearer ${tokenData.access_token}`
        }
      });
      
      // V√©rifier si la r√©ponse est OK
      if (!userResponse.ok) {
        const errorText = await userResponse.text();
        console.error('Erreur lors de la r√©cup√©ration des infos utilisateur:', {
          status: userResponse.status,
          statusText: userResponse.statusText,
          error: errorText
        });
        return res.status(500).json({
          success: false,
          message: `Erreur lors de la r√©cup√©ration des infos utilisateur: ${userResponse.status}`
        });
      }
      
      const userData = await userResponse.json();
      
      if (!userData.id) {
        console.error('Erreur lors de la r√©cup√©ration des informations de l\'utilisateur:', userData);
        return res.status(500).json({
          success: false,
          message: 'Erreur lors de la r√©cup√©ration des informations de l\'utilisateur Discord'
        });
      }
      
      // Supprimer les liens existants pour √©viter les duplications
      await DiscordLink.deleteMany({ $or: [{ discordId: userData.id }, { walletAddress }] });
      
      // Compter le nombre total d'utilisateurs pour d√©terminer l'ordre d'inscription
      const totalUsers = await DiscordLink.countDocuments();
      
      // Cr√©er un nouveau document Discord Link
      const discordLink = new DiscordLink({
        walletAddress,
        discordId: userData.id,
        discordUsername: userData.username,
        discordAvatar: userData.avatar,
        registrationOrder: totalUsers + 1,
        notifyDailyClaims: true,
        roles: [],
        createdAt: Date.now(),
        updatedAt: Date.now()
      });
      
      await discordLink.save();
      console.log(`Lien Discord cr√©√© avec succ√®s pour ${userData.username} (${userData.id}) avec le wallet ${walletAddress}`);
      
      // Ajouter l'utilisateur au serveur Discord s'il n'en est pas d√©j√† membre
      console.log(`Tentative d'ajout de l'utilisateur ${maskDiscordId(userData.id)} au serveur Discord`);
      const addedToGuild = await addUserToGuild(userData.id, tokenData.access_token);
      if (addedToGuild) {
        console.log(`Utilisateur ${maskDiscordId(userData.id)} ajout√© au serveur Discord avec succ√®s`);
        
        // Attendre que Discord synchronise l'ajout du membre (2 secondes)
        console.log(`Attente de 2 secondes pour la synchronisation Discord...`);
        await new Promise(resolve => setTimeout(resolve, 2000));
      } else {
        console.warn(`Impossible d'ajouter l'utilisateur ${maskDiscordId(userData.id)} au serveur Discord`);
      }
      
      // V√©rifier si l'utilisateur est parmi les 5000 premiers pour le r√¥le Early Contributor
      let isEarlyContributor = false;
      if (discordLink.registrationOrder <= 5000) {
        console.log(`L'utilisateur ${userData.username} est parmi les 5000 premiers (position: ${discordLink.registrationOrder})`);
        // Attribuer le r√¥le "Early Contributor"
        const roleAssigned = await assignRoleToUser(userData.id, "Early Contributor");
        
        if (roleAssigned) {
          console.log(`R√¥le Early Contributor attribu√© √† ${userData.username}`);
          // Ajouter le r√¥le √† la liste des r√¥les de l'utilisateur
          discordLink.roles.push("Early Contributor");
          await discordLink.save();
          isEarlyContributor = true;
          
          // Envoyer un message priv√© √† l'utilisateur
          await sendDirectMessageToUser(userData.id, `üåü **Congratulations!** As one of our first 5,000 users, you've been granted the **Early Contributor** role in our Discord server. Thank you for your early support of our decentralized VPN network!`);
        }
      }
      
      // Envoyer un message dans le canal Discord
      await sendMessageToDiscordChannel(`üîó Le wallet \`${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}\` a li√© son compte Discord \`${userData.username}\` (ID: ${userData.id.slice(0, 3)}***${userData.id.slice(-2)})`);

      
      return res.json({
        success: true,
        message: 'Compte Discord li√© avec succ√®s',
        isEarlyContributor
      });
      
    } catch (error) {
      console.error('Erreur lors de la liaison Discord:', error);
      return res.status(500).json({
        success: false,
        message: 'Erreur lors de la liaison Discord: ' + (error.message || 'Erreur inconnue')
      });
    }
  } catch (error) {
    console.error('Erreur g√©n√©rale lors de la liaison Discord:', error);
    return res.status(500).json({
      success: false,
      message: 'Erreur lors de la liaison Discord'
    });
  }
});

// Route de callback pour l'authentification Discord
router.get('/callback', async (req, res) => {
  const { code, state } = req.query;
  
  if (!code) {
    return res.status(400).json({
      success: false,
      message: 'Code d\'autorisation manquant dans la requ√™te'
    });
  }
  
  try {
    // R√©cup√©rer le walletAddress depuis le token JWT dans les cookies ou les headers
    // V√©rifier d'abord si req.cookies existe pour √©viter l'erreur
    const token = req.cookies?.token || 
                 (req.headers.authorization ? req.headers.authorization.split(' ')[1] : null) ||
                 req.query.token; // Essayer aussi de r√©cup√©rer le token depuis les param√®tres d'URL
    
    console.log('Tentative de r√©cup√©ration du token:', { 
      hasCookies: !!req.cookies,
      hasAuthHeader: !!req.headers.authorization,
      hasTokenQuery: !!req.query.token,
      token: token ? `${token.substring(0, 10)}...` : null 
    });
    
    let walletAddress;
    
    if (token) {
      try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        walletAddress = decoded.walletAddress || decoded.address;
        console.log('WalletAddress r√©cup√©r√©e du token:', walletAddress);
      } catch (err) {
        console.error('Erreur de d√©codage du JWT:', err);
      }
    } else {
      console.log('Aucun token trouv√© dans la requ√™te');
    }
    
    // Si pas de walletAddress dans le JWT, rediriger vers le frontend avec le code
    // pour que le frontend puisse compl√©ter la liaison
    if (!walletAddress) {
      console.log('Pas de walletAddress trouv√©e, redirection vers le frontend');
      // Rediriger vers le frontend avec le code et l'√©tat
      const frontendUrl = process.env.FRONTEND_URL || 'https://wind-frontend-rosy.vercel.app';
      const redirectUrl = `${frontendUrl}/discord/callback?code=${code}&state=${state}&noToken=true`;
      console.log('Redirection vers:', redirectUrl);
      return res.redirect(redirectUrl);
    }
    
    // V√©rifier que les variables d'environnement Discord sont d√©finies
    if (!DISCORD_CLIENT_ID || !DISCORD_CLIENT_SECRET) {
      console.error('Variables d\'environnement Discord manquantes:', { 
        DISCORD_CLIENT_ID: !!DISCORD_CLIENT_ID, 
        DISCORD_CLIENT_SECRET: !!DISCORD_CLIENT_SECRET 
      });
      return res.status(500).json({
        success: false,
        message: 'Configuration Discord manquante sur le serveur'
      });
    }

    // √âchanger le code contre un token d'acc√®s Discord
    try {
      const tokenResponse = await fetch(`${DISCORD_API_ENDPOINT}/oauth2/token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: new URLSearchParams({
          client_id: DISCORD_CLIENT_ID,
          client_secret: DISCORD_CLIENT_SECRET,
          grant_type: 'authorization_code',
          code,
          redirect_uri: DISCORD_REDIRECT_URI
        })
      });
      
      // V√©rifier si la r√©ponse est OK
      if (!tokenResponse.ok) {
        const errorText = await tokenResponse.text();
        console.error('Erreur lors de l\'obtention du token Discord:', {
          status: tokenResponse.status,
          statusText: tokenResponse.statusText,
          error: errorText
        });
        return res.status(500).json({
          success: false,
          message: `Erreur lors de l'√©change du code: ${tokenResponse.status} ${tokenResponse.statusText}`
        });
      }
      
      const tokenData = await tokenResponse.json();
      
      if (!tokenData.access_token) {
        console.error('Erreur lors de l\'√©change du code:', tokenData);
        return res.status(500).json({
          success: false,
          message: 'Erreur lors de l\'√©change du code d\'autorisation'
        });
      }
      
      // R√©cup√©rer les informations de l'utilisateur Discord
      const userResponse = await fetch(`${DISCORD_API_ENDPOINT}/users/@me`, {
        headers: {
          Authorization: `Bearer ${tokenData.access_token}`
        }
      });
      
      // V√©rifier si la r√©ponse est OK
      if (!userResponse.ok) {
        const errorText = await userResponse.text();
        console.error('Erreur lors de la r√©cup√©ration des infos utilisateur:', {
          status: userResponse.status,
          statusText: userResponse.statusText,
          error: errorText
        });
        return res.status(500).json({
          success: false,
          message: `Erreur lors de la r√©cup√©ration des infos utilisateur: ${userResponse.status}`
        });
      }
      
      const userData = await userResponse.json();
      
      if (!userData.id) {
        console.error('Erreur lors de la r√©cup√©ration des informations de l\'utilisateur:', userData);
        return res.status(500).json({
          success: false,
          message: 'Erreur lors de la r√©cup√©ration des informations de l\'utilisateur Discord'
        });
      }
    } catch (error) {
      console.error('Erreur lors de la communication avec Discord:', error);
      return res.status(500).json({
        success: false,
        message: 'Erreur lors de la communication avec Discord'
      });
    }
    
    try {
      console.log(`Tentative de liaison du compte Discord ${userData.id} (${userData.username}) avec le wallet ${walletAddress}`);
      
      // IMPORTANT: Supprimer d'abord tous les liens existants pour √©viter les erreurs de cl√© dupliqu√©e
      console.log(`Suppression pr√©ventive de tous les liens existants pour le discordId ${userData.id} ou le wallet ${walletAddress}`);
      const deleteResult = await DiscordLink.deleteMany({ $or: [{ discordId: userData.id }, { walletAddress }] });
      console.log(`${deleteResult.deletedCount} liens supprim√©s`);
      
      // Compter le nombre total d'utilisateurs pour d√©terminer l'ordre d'inscription
      const totalUsers = await DiscordLink.countDocuments();
      
      // Cr√©er un nouveau document Discord Link
      const discordLink = new DiscordLink({
        walletAddress,
        discordId: userData.id,
        discordUsername: userData.username,
        discordAvatar: userData.avatar,
        registrationOrder: totalUsers + 1,
        notifyDailyClaims: true,
        roles: [],
        createdAt: Date.now(),
        updatedAt: Date.now()
      });
      
      console.log(`Cr√©ation d'un nouveau lien Discord pour ${userData.id} (${userData.username}) avec le wallet ${walletAddress}`);
      await discordLink.save();
      console.log(`Lien Discord cr√©√© avec succ√®s, ID: ${discordLink._id}`);
      
      // Ajouter l'utilisateur au serveur Discord s'il n'en est pas d√©j√† membre
      console.log(`Tentative d'ajout de l'utilisateur ${maskDiscordId(userData.id)} au serveur Discord`);
      const addedToGuild = await addUserToGuild(userData.id, tokenData.access_token);
      if (addedToGuild) {
        console.log(`Utilisateur ${maskDiscordId(userData.id)} ajout√© au serveur Discord avec succ√®s`);
        
        // Attendre que Discord synchronise l'ajout du membre (2 secondes)
        console.log(`Attente de 2 secondes pour la synchronisation Discord...`);
        await new Promise(resolve => setTimeout(resolve, 2000));
      } else {
        console.warn(`Impossible d'ajouter l'utilisateur ${maskDiscordId(userData.id)} au serveur Discord`);
      }
      
      // V√©rifier si l'utilisateur est parmi les 5000 premiers pour le r√¥le Early Contributor
      if (discordLink.registrationOrder <= 5000) {
        console.log(`L'utilisateur ${userData.username} est parmi les 5000 premiers (position: ${discordLink.registrationOrder})`);
        
        // D√©clarer la variable roleAssigned en dehors des blocs conditionnels
        let roleAssigned = false;
        
        // Attribuer le r√¥le "Early Contributor" seulement si l'utilisateur a √©t√© ajout√© au serveur
        if (addedToGuild) {
          console.log(`Tentative d'attribution du r√¥le Early Contributor √† ${userData.username}`);
          roleAssigned = await assignRoleToUser(userData.id, "Early Contributor");
        } else {
          console.warn(`Attribution du r√¥le ignor√©e car l'utilisateur n'a pas pu √™tre ajout√© au serveur`);
        }
        
        if (roleAssigned) {
          console.log(`R√¥le Early Contributor attribu√© √† ${userData.username}`);
          // Ajouter le r√¥le √† la liste des r√¥les de l'utilisateur
          discordLink.roles.push("Early Contributor");
          await discordLink.save();
          
          // Envoyer un message priv√© √† l'utilisateur
          await sendDirectMessageToUser(userData.id, `üåü **Congratulations!** As one of our first 5,000 users, you've been granted the **Early Contributor** role in our Discord server. Thank you for your early support of our decentralized VPN network!`);
        }
      }
      
      // Envoyer un message dans le canal Discord
     await sendMessageToDiscordChannel(`üîó Le wallet \`${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}\` a li√© son compte Discord \`${userData.username}\` (ID: ${userData.id.slice(0, 3)}***${userData.id.slice(-2)})`);
      
    } catch (error) {
      console.error('Erreur lors de la liaison Discord:', error);
      
      // G√©rer sp√©cifiquement l'erreur de cl√© dupliqu√©e
      if (error.code === 11000) {
        console.log('Erreur de cl√© dupliqu√©e d√©tect√©e, tentative de r√©solution d√©sesp√©r√©e...');
        
        try {
          // Attendre un peu pour √©viter les conflits de timing
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Supprimer TOUS les liens existants qui pourraient causer des conflits
          console.log(`Suppression d'urgence de tous les liens pour ${userData.id} ou ${walletAddress}`);
          await DiscordLink.collection.deleteMany({ $or: [{ discordId: userData.id }, { walletAddress }] });
          
          // Attendre encore un peu
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Cr√©er un nouveau lien apr√®s avoir supprim√© les liens conflictuels
          const totalUsers = await DiscordLink.countDocuments();
          
          console.log(`Tentative de cr√©ation d'un nouveau lien apr√®s suppression des conflits`);
          const newDiscordLink = new DiscordLink({
            walletAddress,
            discordId: userData.id,
            discordUsername: userData.username,
            discordAvatar: userData.avatar,
            registrationOrder: totalUsers + 1,
            notifyDailyClaims: true,
            roles: [],
            createdAt: Date.now(),
            updatedAt: Date.now()
          });
          
          await newDiscordLink.save();
          console.log(`Nouveau lien cr√©√© avec succ√®s apr√®s r√©solution de conflit, ID: ${newDiscordLink._id}`);
          
          // Envoyer un message dans le canal Discord
          await sendMessageToDiscordChannel(`üîó Apr√®s r√©solution de conflit, le wallet \`${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}\` a li√© son compte Discord \`${userData.username}\` (ID: ${userData.id.slice(0, 3)}***${userData.id.slice(-2)})`);
        } catch (secondError) {
          console.error('Erreur lors de la seconde tentative de liaison Discord:', secondError);
          throw secondError; // Propager l'erreur pour la g√©rer dans le bloc catch parent
        }
      } else {
        // Pour les autres types d'erreurs, propager l'erreur
        throw error;
      }
    }
    
    // Rediriger vers le frontend avec un message de succ√®s
    try {
      // V√©rifier que la liaison a bien √©t√© effectu√©e
      const verificationLink = await DiscordLink.findOne({ discordId: userData.id, walletAddress });
      console.log('V√©rification de la liaison:', verificationLink ? 'Liaison trouv√©e' : 'Liaison NON trouv√©e');
      
      if (!verificationLink) {
        console.warn(`ATTENTION: La liaison entre ${userData.id} et ${walletAddress} n'a pas √©t√© trouv√©e apr√®s le processus!`);
        // Essayer de cr√©er la liaison une derni√®re fois
        try {
          console.log('Tentative de cr√©ation de liaison de secours...');
          const totalUsers = await DiscordLink.countDocuments();
          const emergencyLink = new DiscordLink({
            walletAddress,
            discordId: userData.id,
            discordUsername: userData.username,
            discordAvatar: userData.avatar,
            registrationOrder: totalUsers + 1,
            notifyDailyClaims: true,
            roles: [],
            createdAt: Date.now(),
            updatedAt: Date.now()
          });
          await emergencyLink.save();
          console.log('Liaison de secours cr√©√©e avec succ√®s!');
        } catch (emergencyError) {
          console.error('Erreur lors de la cr√©ation de la liaison de secours:', emergencyError);
        }
      }
      
      // Construire l'URL de redirection vers le frontend
      const frontendUrl = process.env.FRONTEND_URL || 'https://lastexitfromnowhere.github.io/vpn-frontend';
      const redirectUrl = `${frontendUrl}?discordLinked=true&username=${encodeURIComponent(userData.username)}`;
      
      console.log(`Redirection vers ${redirectUrl}`);
      res.header('Access-Control-Allow-Origin', '*');
      res.header('Access-Control-Allow-Methods', 'GET');
      res.header('Access-Control-Allow-Headers', 'Content-Type');
      
      // Rediriger l'utilisateur vers le frontend
      return res.redirect(redirectUrl);
    } catch (redirectError) {
      console.error('Erreur lors de la redirection:', redirectError);
      // En cas d'erreur de redirection, renvoyer un JSON
      return res.json({
        success: true,
        message: 'Compte Discord li√© avec succ√®s, mais erreur lors de la redirection',
        discordUser: {
          id: userData.id,
          username: userData.username,
          avatar: userData.avatar
        }
      });
    }
  } catch (error) {
    console.error('Erreur lors de l\'authentification Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de l\'authentification Discord'
    });
  }
});

// Route de diagnostic sans authentification pour v√©rifier l'√©tat du serveur Discord
router.get('/link-debug', async (req, res) => {
  // D√©finir les en-t√™tes CORS explicitement pour cette route
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET');
  res.header('Access-Control-Allow-Headers', 'Content-Type');
  
  res.json({
    success: true,
    message: 'Route de diagnostic Discord fonctionnelle',
    serverTime: new Date().toISOString(),
    discordConfig: {
      clientId: DISCORD_CLIENT_ID,
      redirectUri: DISCORD_REDIRECT_URI
    }
  });
});

// Route pour r√©cup√©rer les informations du compte Discord li√©
router.get('/link', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    
    console.log(`V√©rification de liaison Discord pour le wallet: ${walletAddress}`);
    
    if (!walletAddress) {
      console.log('Erreur: Wallet non fourni dans la requ√™te');
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    // V√©rifier toutes les liaisons existantes pour ce wallet
    const allLinks = await DiscordLink.find({ walletAddress });
    console.log(`Nombre de liaisons trouv√©es pour ${walletAddress}: ${allLinks.length}`);
    
    if (allLinks.length > 0) {
      allLinks.forEach((link, index) => {
        console.log(`Liaison ${index+1}:`, {
          discordId: link.discordId,
          username: link.discordUsername,
          createdAt: link.createdAt
        });
      });
    }
    
    const discordLink = allLinks.length > 0 ? allLinks[0] : null;
    
    if (!discordLink) {
      console.log(`Aucune liaison Discord trouv√©e pour le wallet ${walletAddress}`);
      return res.status(200).json({
        success: true,
        message: 'Aucun compte Discord li√© √† ce wallet',
        isLinked: false
      });
    }
    
    console.log(`Liaison Discord trouv√©e pour ${walletAddress}:`, {
      discordId: discordLink.discordId,
      username: discordLink.discordUsername
    });
    
    res.json({
      success: true,
      isLinked: true,
      discordUser: {
        id: discordLink.discordId,
        username: discordLink.discordUsername,
        avatar: discordLink.discordAvatar
      }
    });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration du lien Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration du lien Discord'
    });
  }
});

// Route pour v√©rifier la disponibilit√© du serveur Discord (sans authentification)
router.get('/status', async (req, res) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, x-wallet-address');
  
  // G√©rer les requ√™tes OPTIONS pour le pre-flight CORS
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  
  try {
    // V√©rifier si le serveur Discord est accessible
    const response = await fetch(`${DISCORD_API_ENDPOINT}/users/@me`, {
      headers: {
        'Content-Type': 'application/json'
      }
    });

    // M√™me si la requ√™te √©choue avec 401, cela signifie que le serveur Discord est accessible
    res.json({
      success: true,
      isAvailable: true,
      message: 'Le serveur Discord est accessible'
    });
  } catch (error) {
    console.error('Erreur lors de la v√©rification du statut Discord:', error);
    res.json({
      success: false,
      isAvailable: false,
      message: 'Le serveur Discord est inaccessible'
    });
  }
});

// Route pour v√©rifier le statut de liaison Discord (avec authentification)
router.get('/link-status', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    // V√©rifier toutes les liaisons existantes pour ce wallet
    const discordLink = await DiscordLink.findOne({ walletAddress });
    
    if (!discordLink) {
      return res.json({
        linked: false,
        discordUsername: null,
        discordAvatar: null,
        discordId: null,
        notifyDailyClaims: false,
        isEarlyContributor: false,
        registrationOrder: null
      });
    }
    
    // D√©terminer si l'utilisateur est un early contributor (parmi les 5000 premiers)
    const isEarlyContributor = discordLink.registrationOrder <= 5000;
    
    res.json({
      linked: true,
      discordUsername: discordLink.discordUsername,
      discordAvatar: discordLink.discordAvatar,
      discordId: discordLink.discordId,
      notifyDailyClaims: discordLink.notifyDailyClaims !== undefined ? discordLink.notifyDailyClaims : true,
      isEarlyContributor,
      registrationOrder: discordLink.registrationOrder
    });
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration du statut Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration du statut Discord'
    });
  }
});

// Route pour supprimer le lien entre un wallet et un compte Discord
router.delete('/link', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    const discordLink = await DiscordLink.findOne({ walletAddress });
    
    if (!discordLink) {
      return res.status(404).json({
        success: false,
        message: 'Aucun compte Discord li√© √† ce wallet'
      });
    }
    
    const discordUsername = discordLink.discordUsername;
    
    await DiscordLink.deleteOne({ walletAddress });
    
    // Envoyer un message dans le canal Discord
    await sendMessageToDiscordChannel(`‚ùå Le wallet \`${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}\` a supprim√© son lien avec le compte Discord \`${discordUsername}\``);

    
    res.json({
      success: true,
      message: 'Lien Discord supprim√© avec succ√®s'
    });
  } catch (error) {
    console.error('Erreur lors de la suppression du lien Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression du lien Discord'
    });
  }
});

// Route pour activer/d√©sactiver les notifications de daily claims
router.post('/notifications/daily-claims', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    const { enabled } = req.body;
    
    if (enabled === undefined) {
      return res.status(400).json({
        success: false,
        message: 'Le param√®tre "enabled" est requis'
      });
    }
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    const discordLink = await DiscordLink.findOne({ walletAddress });
    
    if (!discordLink) {
      return res.status(404).json({
        success: false,
        message: 'Aucun compte Discord li√© √† ce wallet'
      });
    }
    
    // Mettre √† jour les pr√©f√©rences de notification
    discordLink.notifyDailyClaims = enabled;
    await discordLink.save();
    
    // Envoyer un message priv√© √† l'utilisateur pour confirmer
    if (enabled) {
      await sendDirectMessageToUser(discordLink.discordId, `üîî You have **enabled** daily claim notifications. You will now receive a private message when your daily rewards are available to claim.`);
    } else {
      await sendDirectMessageToUser(discordLink.discordId, `üîï You have **disabled** daily claim notifications. You will no longer receive private messages about daily claims.`);
    }
    
    res.json({
      success: true,
      message: enabled ? 'Notifications de daily claims activ√©es' : 'Notifications de daily claims d√©sactiv√©es',
      notifyDailyClaims: enabled
    });
  } catch (error) {
    console.error('Erreur lors de la mise √† jour des pr√©f√©rences de notification:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la mise √† jour des pr√©f√©rences de notification'
    });
  }
});

// Route pour v√©rifier si l'utilisateur est parmi les 5000 premiers
router.get('/early-contributor', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    const discordLink = await DiscordLink.findOne({ walletAddress });
    
    if (!discordLink) {
      return res.status(404).json({
        success: false,
        message: 'Aucun compte Discord li√© √† ce wallet',
        isEarlyContributor: false
      });
    }
    
    const isEarlyContributor = discordLink.registrationOrder <= 5000;
    
    res.json({
      success: true,
      isEarlyContributor,
      registrationOrder: discordLink.registrationOrder,
      roles: discordLink.roles || []
    });
  } catch (error) {
    console.error('Erreur lors de la v√©rification du statut de contributeur pr√©coce:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la v√©rification du statut de contributeur pr√©coce'
    });
  }
});

export default router;
