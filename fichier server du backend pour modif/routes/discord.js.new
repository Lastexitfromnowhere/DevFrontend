import express from 'express';
import fetch from 'node-fetch';
import { authenticateToken } from '../middlewares/auth.js';
import { v4 as uuidv4 } from 'uuid';
import DiscordLink from '../models/DiscordLink.js';
import { sendMessageToDiscordChannel, sendDirectMessageToUser, assignRoleToUser, addUserToGuild } from '../utils/sendDiscordMessage.js';
import { maskWalletAddress, maskDiscordId } from '../utils/privacyUtils.js';

const router = express.Router();

// V√©rifier si le serveur Discord est en ligne
router.get('/status', async (req, res) => {
  try {
    const response = await fetch('https://discord.com/api/v10/users/@me', {
      headers: {
        Authorization: `Bot ${process.env.DISCORD_TOKEN}`
      }
    });
    
    if (response.ok) {
      const botData = await response.json();
      res.json({
        success: true,
        message: 'Le serveur Discord est en ligne',
        botUsername: botData.username
      });
    } else {
      res.status(response.status).json({
        success: false,
        message: `Erreur lors de la v√©rification du serveur Discord: ${response.statusText}`
      });
    }
  } catch (error) {
    console.error('Erreur lors de la v√©rification du serveur Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la v√©rification du serveur Discord'
    });
  }
});

// V√©rifier si un utilisateur a li√© son compte Discord
router.get('/link-status', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    const discordLink = await DiscordLink.findOne({ walletAddress });
    
    if (!discordLink) {
      return res.json({
        linked: false
      });
    }
    
    return res.json({
      linked: true,
      discordUsername: discordLink.discordUsername,
      discordAvatar: discordLink.discordAvatar,
      discordId: discordLink.discordId,
      notifyDailyClaims: discordLink.notifyDailyClaims,
      isEarlyContributor: discordLink.registrationOrder <= 5000,
      registrationOrder: discordLink.registrationOrder
    });
  } catch (error) {
    console.error('Erreur lors de la v√©rification du statut Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la v√©rification du statut Discord'
    });
  }
});

// Mettre √† jour les pr√©f√©rences de notification
router.post('/notifications', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    const { notifyDailyClaims } = req.body;
    
    if (notifyDailyClaims === undefined) {
      return res.status(400).json({
        success: false,
        message: 'Le param√®tre notifyDailyClaims est requis'
      });
    }
    
    const discordLink = await DiscordLink.findOne({ walletAddress });
    
    if (!discordLink) {
      return res.status(404).json({
        success: false,
        message: 'Aucun compte Discord li√© √† ce wallet'
      });
    }
    
    discordLink.notifyDailyClaims = notifyDailyClaims;
    discordLink.updatedAt = Date.now();
    await discordLink.save();
    
    res.json({
      success: true,
      message: 'Pr√©f√©rences de notification mises √† jour avec succ√®s'
    });
  } catch (error) {
    console.error('Erreur lors de la mise √† jour des pr√©f√©rences de notification:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la mise √† jour des pr√©f√©rences de notification'
    });
  }
});

// Lier un compte Discord √† un wallet
router.post('/link', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    const { code, redirectUri } = req.body;
    
    if (!code || !redirectUri) {
      return res.status(400).json({
        success: false,
        message: 'Les param√®tres code et redirectUri sont requis'
      });
    }
    
    // √âchanger le code contre un token d'acc√®s
    const tokenResponse = await fetch('https://discord.com/api/v10/oauth2/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        client_id: process.env.DISCORD_CLIENT_ID,
        client_secret: process.env.DISCORD_CLIENT_SECRET,
        grant_type: 'authorization_code',
        code,
        redirect_uri: redirectUri
      })
    });
    
    if (!tokenResponse.ok) {
      const errorText = await tokenResponse.text();
      console.error('Erreur lors de l\'√©change du code:', {
        status: tokenResponse.status,
        statusText: tokenResponse.statusText,
        error: errorText
      });
      return res.status(400).json({
        success: false,
        message: `Erreur lors de l'√©change du code: ${tokenResponse.status}`
      });
    }
    
    const tokenData = await tokenResponse.json();
    
    // R√©cup√©rer les informations de l'utilisateur Discord
    const userResponse = await fetch('https://discord.com/api/v10/users/@me', {
      headers: {
        Authorization: `Bearer ${tokenData.access_token}`
      }
    });
    
    if (!userResponse.ok) {
      const errorText = await userResponse.text();
      console.error('Erreur lors de la r√©cup√©ration des infos utilisateur:', {
        status: userResponse.status,
        statusText: userResponse.statusText,
        error: errorText
      });
      return res.status(500).json({
        success: false,
        message: `Erreur lors de la r√©cup√©ration des infos utilisateur: ${userResponse.status}`
      });
    }
    
    const userData = await userResponse.json();
    
    if (!userData.id) {
      console.error('Erreur lors de la r√©cup√©ration des informations de l\'utilisateur:', userData);
      return res.status(500).json({
        success: false,
        message: 'Erreur lors de la r√©cup√©ration des informations de l\'utilisateur Discord'
      });
    }
    
    // Supprimer les liens existants pour √©viter les duplications
    await DiscordLink.deleteMany({ $or: [{ discordId: userData.id }, { walletAddress }] });
    
    // Compter le nombre total d'utilisateurs pour d√©terminer l'ordre d'inscription
    const totalUsers = await DiscordLink.countDocuments();
    
    // Cr√©er un nouveau lien
    const discordLink = new DiscordLink({
      walletAddress,
      discordId: userData.id,
      discordUsername: userData.username,
      discordAvatar: userData.avatar,
      registrationOrder: totalUsers + 1,
      notifyDailyClaims: true,
      roles: [],
      createdAt: Date.now(),
      updatedAt: Date.now()
    });
    
    console.log(`Cr√©ation d'un nouveau lien Discord pour ${maskDiscordId(userData.id)} (${userData.username}) avec le wallet ${maskWalletAddress(walletAddress)}`);
    await discordLink.save();
    console.log(`Lien Discord cr√©√© avec succ√®s, ID: ${discordLink._id}`);
    
    // Ajouter l'utilisateur au serveur Discord s'il n'en est pas d√©j√† membre
    console.log(`Tentative d'ajout de l'utilisateur ${maskDiscordId(userData.id)} au serveur Discord`);
    const addedToGuild = await addUserToGuild(userData.id, tokenData.access_token);
    if (addedToGuild) {
      console.log(`Utilisateur ${maskDiscordId(userData.id)} ajout√© au serveur Discord avec succ√®s`);
      
      // Attendre que Discord synchronise l'ajout du membre (5 secondes)
      console.log(`Attente de 5 secondes pour la synchronisation Discord...`);
      await new Promise(resolve => setTimeout(resolve, 5000));
    } else {
      console.warn(`Impossible d'ajouter l'utilisateur ${maskDiscordId(userData.id)} au serveur Discord`);
      // M√™me si l'ajout a √©chou√©, on continue pour essayer d'attribuer le r√¥le
      // car l'utilisateur pourrait d√©j√† √™tre membre du serveur mais l'API a retourn√© une erreur
      console.log(`Tentative d'attribution de r√¥le malgr√© l'√©chec d'ajout au serveur...`);
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
    
    // V√©rifier si l'utilisateur est parmi les 5000 premiers pour le r√¥le Early Contributor
    let isEarlyContributor = false;
    if (discordLink.registrationOrder <= 5000) {
      console.log(`L'utilisateur ${userData.username} est parmi les 5000 premiers (position: ${discordLink.registrationOrder})`);
      isEarlyContributor = true;
      
      // Attribuer le r√¥le Early Contributor
      const roleAssigned = await assignRoleToUser(userData.id, 'Early Contributor');
      if (roleAssigned) {
        console.log(`R√¥le Early Contributor attribu√© √† ${userData.username}`);
        
        // Envoyer un message priv√© √† l'utilisateur
        await sendDirectMessageToUser(userData.id, `üåü **Congratulations!** As one of our first 5,000 users, you've been granted the **Early Contributor** role in our Discord server. Thank you for your early support of our decentralized VPN network!`);
      }
    }
    
    // Envoyer un message dans le canal Discord
    await sendMessageToDiscordChannel(`üîó Le wallet \`${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}\` a li√© son compte Discord \`${userData.username}\` (ID: ${userData.id.slice(0, 3)}***${userData.id.slice(-2)})`);
    
    return res.json({
      success: true,
      message: 'Compte Discord li√© avec succ√®s',
      isEarlyContributor
    });
    
  } catch (error) {
    console.error('Erreur lors de la liaison Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la liaison Discord'
    });
  }
});

// Route de callback pour l'authentification Discord
router.get('/callback', async (req, res) => {
  try {
    const { code, state } = req.query;
    
    if (!code) {
      return res.status(400).json({
        success: false,
        message: 'Le param√®tre code est requis'
      });
    }
    
    // √âchanger le code contre un token d'acc√®s
    const tokenResponse = await fetch('https://discord.com/api/v10/oauth2/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        client_id: process.env.DISCORD_CLIENT_ID,
        client_secret: process.env.DISCORD_CLIENT_SECRET,
        grant_type: 'authorization_code',
        code,
        redirect_uri: process.env.DISCORD_REDIRECT_URI
      })
    });
    
    if (!tokenResponse.ok) {
      const errorText = await tokenResponse.text();
      console.error('Erreur lors de l\'√©change du code:', {
        status: tokenResponse.status,
        statusText: tokenResponse.statusText,
        error: errorText
      });
      return res.status(400).json({
        success: false,
        message: `Erreur lors de l'√©change du code: ${tokenResponse.status}`
      });
    }
    
    const tokenData = await tokenResponse.json();
    
    // R√©cup√©rer les informations de l'utilisateur Discord
    const userResponse = await fetch('https://discord.com/api/v10/users/@me', {
      headers: {
        Authorization: `Bearer ${tokenData.access_token}`
      }
    });
    
    if (!userResponse.ok) {
      const errorText = await userResponse.text();
      console.error('Erreur lors de la r√©cup√©ration des infos utilisateur:', {
        status: userResponse.status,
        statusText: userResponse.statusText,
        error: errorText
      });
      return res.status(500).json({
        success: false,
        message: `Erreur lors de la r√©cup√©ration des infos utilisateur: ${userResponse.status}`
      });
    }
    
    const userData = await userResponse.json();
    
    if (!userData.id) {
      console.error('Erreur lors de la r√©cup√©ration des informations de l\'utilisateur:', userData);
      return res.status(500).json({
        success: false,
        message: 'Erreur lors de la r√©cup√©ration des informations de l\'utilisateur Discord'
      });
    }
    
    // V√©rifier si l'utilisateur a d√©j√† li√© son compte
    const existingLink = await DiscordLink.findOne({ discordId: userData.id });
    
    if (existingLink) {
      // Mettre √† jour les informations Discord
      existingLink.discordUsername = userData.username;
      existingLink.discordAvatar = userData.avatar;
      existingLink.updatedAt = Date.now();
      await existingLink.save();
      
      // Envoyer un message dans le canal Discord
      await sendMessageToDiscordChannel(`üîó Le wallet \`${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}\` a li√© son compte Discord \`${userData.username}\` (ID: ${userData.id.slice(0, 3)}***${userData.id.slice(-2)})`);
      
    } catch (error) {
      console.error('Erreur lors de la liaison Discord:', error);
      
      // Tenter de r√©soudre les conflits de liaison
      if (error.name === 'MongoError' && (error.code === 11000 || error.code === 11001)) {
        try {
          console.log('Tentative de r√©solution de conflit de liaison Discord...');
          
          // Attendre un peu pour √©viter les conditions de course
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Supprimer TOUS les liens existants qui pourraient causer des conflits
          console.log(`Suppression d'urgence de tous les liens pour ${userData.id} ou ${walletAddress}`);
          await DiscordLink.collection.deleteMany({ $or: [{ discordId: userData.id }, { walletAddress }] });
          
          // Attendre encore un peu
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Cr√©er un nouveau lien apr√®s avoir supprim√© les liens conflictuels
          const totalUsers = await DiscordLink.countDocuments();
          
          console.log(`Tentative de cr√©ation d'un nouveau lien apr√®s suppression des conflits`);
          const newDiscordLink = new DiscordLink({
            walletAddress,
            discordId: userData.id,
            discordUsername: userData.username,
            discordAvatar: userData.avatar,
            registrationOrder: totalUsers + 1,
            notifyDailyClaims: true,
            roles: [],
            createdAt: Date.now(),
            updatedAt: Date.now()
          });
          
          await newDiscordLink.save();
          console.log(`Nouveau lien cr√©√© avec succ√®s apr√®s r√©solution de conflit, ID: ${newDiscordLink._id}`);
          
          // Envoyer un message dans le canal Discord
          await sendMessageToDiscordChannel(`üîó Apr√®s r√©solution de conflit, le wallet \`${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}\` a li√© son compte Discord \`${userData.username}\` (ID: ${userData.id.slice(0, 3)}***${userData.id.slice(-2)})`);
        } catch (secondError) {
          console.error('Erreur lors de la seconde tentative de liaison Discord:', secondError);
          throw secondError; // Propager l'erreur pour la g√©rer dans le bloc catch parent
        }
      } else {
        // Pour les autres types d'erreurs, propager l'erreur
        throw error;
      }
    }
    
    // Rediriger vers le frontend avec un message de succ√®s
    try {
      // V√©rifier que la liaison a bien √©t√© effectu√©e
      const verificationLink = await DiscordLink.findOne({ discordId: userData.id, walletAddress });
      console.log('V√©rification de la liaison:', verificationLink ? 'Liaison trouv√©e' : 'Liaison NON trouv√©e');
      
      if (!verificationLink) {
        console.warn(`ATTENTION: La liaison entre ${userData.id} et ${walletAddress} n'a pas √©t√© trouv√©e apr√®s le processus!`);
        // Essayer de cr√©er la liaison une derni√®re fois
        try {
          console.log('Tentative de cr√©ation de liaison de secours...');
          const emergencyLink = new DiscordLink({
            walletAddress,
            discordId: userData.id,
            discordUsername: userData.username,
            discordAvatar: userData.avatar,
            registrationOrder: await DiscordLink.countDocuments() + 1,
            notifyDailyClaims: true,
            roles: [],
            createdAt: Date.now(),
            updatedAt: Date.now()
          });
          await emergencyLink.save();
          console.log('Liaison de secours cr√©√©e avec succ√®s!');
        } catch (emergencyError) {
          console.error('Erreur lors de la cr√©ation de la liaison de secours:', emergencyError);
        }
      }
      
      // Construire l'URL de redirection vers le frontend
      const frontendUrl = process.env.FRONTEND_URL || 'https://lastexitfromnowhere.github.io/vpn-frontend';
      const redirectUrl = `${frontendUrl}?discordLinked=true&username=${encodeURIComponent(userData.username)}`;
      
      console.log(`Redirection vers ${redirectUrl}`);
      res.header('Access-Control-Allow-Origin', '*');
      res.header('Access-Control-Allow-Methods', 'GET');
      res.header('Access-Control-Allow-Headers', 'Content-Type');
      
      // Rediriger l'utilisateur vers le frontend
      return res.redirect(redirectUrl);
    } catch (redirectError) {
      console.error('Erreur lors de la redirection:', redirectError);
      res.status(500).json({
        success: false,
        message: 'Erreur lors de la redirection'
      });
    }
  } catch (error) {
    console.error('Erreur lors de l\'authentification Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de l\'authentification Discord'
    });
  }
});

// Route de diagnostic sans authentification pour v√©rifier l'√©tat du serveur Discord
router.get('/link-debug', async (req, res) => {
  // D√©finir les en-t√™tes CORS explicitement pour cette route
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET');
  res.header('Access-Control-Allow-Headers', 'Content-Type');
  
  res.json({
    success: true,
    message: 'Serveur Discord disponible',
    env: {
      DISCORD_CLIENT_ID: process.env.DISCORD_CLIENT_ID ? 'D√©fini' : 'Non d√©fini',
      DISCORD_CLIENT_SECRET: process.env.DISCORD_CLIENT_SECRET ? 'D√©fini' : 'Non d√©fini',
      DISCORD_REDIRECT_URI: process.env.DISCORD_REDIRECT_URI,
      DISCORD_GUILD_ID: process.env.DISCORD_GUILD_ID ? 'D√©fini' : 'Non d√©fini',
      DISCORD_TOKEN: process.env.DISCORD_TOKEN ? 'D√©fini' : 'Non d√©fini',
      DISCORD_CHANNEL_ID: process.env.DISCORD_CHANNEL_ID ? 'D√©fini' : 'Non d√©fini'
    }
  });
});

// V√©rifier le statut d'un lien Discord
router.get('/link-check/:discordId', async (req, res) => {
  try {
    const { discordId } = req.params;
    
    if (!discordId) {
      return res.status(400).json({
        success: false,
        message: 'Le param√®tre discordId est requis'
      });
    }
    
    const discordLink = await DiscordLink.findOne({ discordId });
    
    if (!discordLink) {
      return res.json({
        success: true,
        linked: false
      });
    }
    
    res.json({
      success: true,
      linked: true,
      walletAddress: discordLink.walletAddress,
      discordUsername: discordLink.discordUsername,
      registrationOrder: discordLink.registrationOrder,
      isEarlyContributor: discordLink.registrationOrder <= 5000
    });
  } catch (error) {
    console.error('Erreur lors de la v√©rification du lien Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration du statut Discord'
    });
  }
});

// Route pour supprimer le lien entre un wallet et un compte Discord
router.delete('/link', authenticateToken, async (req, res) => {
  try {
    const walletAddress = req.user.address || req.user.walletAddress;
    
    if (!walletAddress) {
      return res.status(401).json({
        success: false,
        message: 'Vous devez √™tre connect√© avec un wallet pour acc√©der √† cette ressource'
      });
    }
    
    const discordLink = await DiscordLink.findOne({ walletAddress });
    
    if (!discordLink) {
      return res.status(404).json({
        success: false,
        message: 'Aucun compte Discord li√© √† ce wallet'
      });
    }
    
    const discordUsername = discordLink.discordUsername;
    
    await DiscordLink.deleteOne({ walletAddress });
    
    // Envoyer un message dans le canal Discord
    await sendMessageToDiscordChannel(`‚ùå Le wallet \`${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}\` a supprim√© son lien avec le compte Discord \`${discordUsername}\``);
    
    res.json({
      success: true,
      message: 'Lien Discord supprim√© avec succ√®s'
    });
  } catch (error) {
    console.error('Erreur lors de la suppression du lien Discord:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression du lien Discord'
    });
  }
});

export default router;
